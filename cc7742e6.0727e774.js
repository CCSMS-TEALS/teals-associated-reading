(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{76:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return r})),n.d(t,"toc",(function(){return c})),n.d(t,"CenteredDiv",(function(){return b})),n.d(t,"default",(function(){return h}));var a=n(3),i=n(7),s=(n(0),n(88)),o=n(81),l={id:"unit2",title:"Unit 2 - Data Types, Conditionals, Booleans and Lists",sidebar_label:"Unit 2 - Data Types, Conditionals, Booleans and Lists",slug:"/unit2"},r={unversionedId:"unit2",id:"unit2",isDocsHomePage:!1,title:"Unit 2 - Data Types, Conditionals, Booleans and Lists",description:"(<div style={{",source:"@site/docs/unit2.mdx",slug:"/unit2",permalink:"/teals-associated-reading/docs/unit2",editUrl:"https://github.com/CCSMS-TEALS/teals-associated-reading/docs/unit2.mdx",version:"current",sidebar_label:"Unit 2 - Data Types, Conditionals, Booleans and Lists",sidebar:"someSidebar",previous:{title:"Unit 1 - Introduction to Python",permalink:"/teals-associated-reading/docs/"}},c=[{value:"2.1",id:"21",children:[{value:"Values and types",id:"values-and-types",children:[]}]},{value:"2.2",id:"22",children:[{value:"Expressions and statements",id:"expressions-and-statements",children:[]},{value:"Boolean expressions",id:"boolean-expressions",children:[]},{value:"Logical operators",id:"logical-operators",children:[]}]},{value:"2.3",id:"23",children:[{value:"Conditional execution",id:"conditional-execution",children:[]},{value:"Alternative execution",id:"alternative-execution",children:[]},{value:"Chained conditionals",id:"chained-conditionals",children:[]},{value:"Nested conditionals",id:"nested-conditionals",children:[]}]},{value:"2.4",id:"24",children:[{value:"A list is a sequence",id:"a-list-is-a-sequence",children:[]},{value:"Lists are mutable",id:"lists-are-mutable",children:[]}]},{value:"2.5",id:"25",children:[{value:"List operations",id:"list-operations",children:[]},{value:"List slices",id:"list-slices",children:[]},{value:"List methods",id:"list-methods",children:[]},{value:"Deleting elements",id:"deleting-elements",children:[]},{value:"The in operator",id:"the-in-operator",children:[]}]},{value:"2.6",id:"26",children:[{value:"The while statement",id:"the-while-statement",children:[]}]}],b=function(e){var t=e.children;return Object(s.b)("div",{style:{width:"50%",margin:"0 auto",textAlign:"center"}},t)},p={toc:c,CenteredDiv:b};function h(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(s.b)("wrapper",Object(a.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h2",{id:"21"},"2.1"),Object(s.b)("h3",{id:"values-and-types"},"Values and types"),Object(s.b)("p",null,"A value is one of the basic things a program works with, like a letter or a number. The values we have seen so far are ",Object(s.b)("inlineCode",{parentName:"p"},"1"),", ",Object(s.b)("inlineCode",{parentName:"p"},"2"),", and ",Object(s.b)("inlineCode",{parentName:"p"},"'Hello, World!'"),"."),Object(s.b)("p",null,"These values belong to different types: ",Object(s.b)("inlineCode",{parentName:"p"},"2")," is an integer, and ",Object(s.b)("inlineCode",{parentName:"p"},"'Hello, World!'")," is a string, so-called because it contains a \u201cstring\u201d of letters. You (and the interpreter) can identify strings because they are enclosed in quotation marks."),Object(s.b)("p",null,"If you are not sure what type a value has, the interpreter can tell you."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> type('Hello, World!')\n<type 'str'=\"\">\n>>> type(17)\n<type 'int'=\"\">\n")),Object(s.b)("p",null,"Not surprisingly, strings belong to the type str and integers belong to the type int. Less obviously, numbers with a decimal point belong to a type called float, because these numbers are represented in a format called ",Object(s.b)("strong",{parentName:"p"},"floating-point.")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> type(3.2)\n<type 'float'=\"\">\n")),Object(s.b)("p",null,"What about values like '17' and '3.2'? They look like numbers,\nbut they are in quotation marks like strings."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> type('17')\n<type 'str'=\"\">\n>>> type('3.2')\n<type 'str'=\"\">\n")),Object(s.b)("p",null,"They\u2019re strings. When you type a large integer, you might be tempted to use commas between groups of three digits, as in 1,000,000. This is not a legal integer in Python, but it is legal:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> 1,000,000\n(1, 0, 0)\n")),Object(s.b)("p",null,"Well, that\u2019s not what we expected at all! Python interprets 1,000,000 as a comma-separated sequence of integers. This is an example we have seen of a ",Object(s.b)("strong",{parentName:"p"},"semantic error"),": the code runs without producing an error message, but it doesn\u2019t do the \u201cright\u201d thing."),Object(s.b)("h4",{id:"practice-exercises"},"Practice Exercises"),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Exercise 1"),"\nAssume that we execute the following assignment statements:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"width = 17\nheight = 12.0\ndelimiter = '.'\n")),Object(s.b)("p",null,"For each of the following expressions, write the value of the expression and the type (of the value of the expression):"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"width/2\nwidth/2.0\nheight/3\n1 + 2 * 5\ndelimiter * 5\n")),Object(s.b)("p",null,"Use the Python interpreter to check your answers."),Object(s.b)("p",null,Object(s.b)("strong",{parentName:"p"},"Exercise 2"),"\nPractice using the Python interpreter as a calculator:"),Object(s.b)("p",null,"The volume of a sphere with radius r is 4/3 \u03c0 r 3. What is the volume of a sphere with radius 5? (Hint: 392.7 is wrong!)"),Object(s.b)("p",null,"Suppose the cover price of a book is $24.95, but bookstores get a 40% discount. Shipping costs $3 for the first copy and 75 cents for each additional copy. What is the total wholesale cost for 60 copies?"),Object(s.b)("p",null,"If I leave my house at 6:52 am and run 1 mile at an easy pace (8:15 per mile), then 3 miles at tempo (7:12 per mile) and 1 mile at easy pace again, what time do I get home for breakfast?"),Object(s.b)("h2",{id:"22"},"2.2"),Object(s.b)("h3",{id:"expressions-and-statements"},"Expressions and statements"),Object(s.b)("p",null,"An expression is a combination of values, variables, and operators. A value all by itself is considered an expression, and so is a variable, so the following are all legal expressions (assuming that the variable x has been assigned a value):"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"17\nx\nx + 17\n")),Object(s.b)("p",null,"A statement is a unit of code that the Python interpreter can execute. We have seen two kinds of statement: print and assignment."),Object(s.b)("p",null,"Technically an expression is also a statement, but it is probably simpler to think of them as different things. The important difference is that an expression has a value; a statement does not."),Object(s.b)("h3",{id:"boolean-expressions"},"Boolean expressions"),Object(s.b)("p",null,"A ",Object(s.b)("strong",{parentName:"p"},"Boolean")," expression is an expression that is either true or false. The following examples use the operator ==, which compares two operands and produces True if they are equal and False otherwise:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> 5 == 5\nTrue\n>>> 5 == 6\nFalse\n")),Object(s.b)("p",null,"True and False are special values that belong to the type bool; ",Object(s.b)("strong",{parentName:"p"},"they are not strings"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> type(True)\n<type 'bool'=\"\">\n>>> type(False)\n<type 'bool'=\"\">\n")),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"==")," operator is one of the relational operators; the others are:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"x != y      # x is not equal to y\nx > y       # x is greater than y\nx < y       # x is less than y\nx >= y      # x is greater than or equal to y\nx <= y      # x is less than or equal to y\n")),Object(s.b)("p",null,"Although these operations are probably familiar to you, the Python symbols are different from the mathematical symbols. A common error is to use a single equal sign (=) instead of a double equal sign (==). ",Object(s.b)("strong",{parentName:"p"},"Remember that = is an assignment operator and == is a relational operator.")," There is no such thing as ",Object(s.b)("inlineCode",{parentName:"p"},"=<")," or ",Object(s.b)("inlineCode",{parentName:"p"},"=>"),"."),Object(s.b)("h3",{id:"logical-operators"},"Logical operators"),Object(s.b)("p",null,"There are three logical operators: ",Object(s.b)("inlineCode",{parentName:"p"},"and"),", ",Object(s.b)("inlineCode",{parentName:"p"},"or"),", and ",Object(s.b)("inlineCode",{parentName:"p"},"not"),". The semantics (meaning) of these operators is similar to their meaning in English. For example, ",Object(s.b)("inlineCode",{parentName:"p"},"x > 0 and x < 10")," is true only if x is greater than 0 and less than 10."),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"n * 2 == 4 or n * 10 == 100")," is true if either of the conditions is true, that is, if the number is 2 or 10."),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"or")," expression is true whenever one of the operands is true and the ",Object(s.b)("inlineCode",{parentName:"p"},"and")," expression is false whenever one of the operands is false."),Object(s.b)("p",null,"Finally, the ",Object(s.b)("inlineCode",{parentName:"p"},"not")," operator negates a Boolean expression, so ",Object(s.b)("inlineCode",{parentName:"p"},"not (x > y)")," is true if ",Object(s.b)("inlineCode",{parentName:"p"},"x > y")," is false, that is, if x is less than or equal to y."),Object(s.b)("p",null,"Strictly speaking, the operands of the logical operators should be Boolean expressions, but ",Object(s.b)("strong",{parentName:"p"},"Python is not very strict. Any nonzero number is interpreted as ",Object(s.b)("inlineCode",{parentName:"strong"},"True"),".")),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> 17 and True\nTrue\n")),Object(s.b)("p",null,"This flexibility can be useful, but there are some subtleties to it that might be confusing. You might want to avoid it (unless you know what you are doing)."),Object(s.b)("h2",{id:"23"},"2.3"),Object(s.b)("h3",{id:"conditional-execution"},"Conditional execution"),Object(s.b)("p",null,"In order to write useful programs, we almost always need the ability to check conditions and change the behavior of the program accordingly. ",Object(s.b)("strong",{parentName:"p"},"Conditional statements")," give us this ability. The simplest form is the if statement:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if x > 0:\n    print('x is positive')\n")),Object(s.b)("p",null,"The Boolean expression after if is called the ",Object(s.b)("strong",{parentName:"p"},"condition"),". ",Object(s.b)("strong",{parentName:"p"},"If")," it is true, ",Object(s.b)("strong",{parentName:"p"},"then")," the indented statement gets executed. If not, nothing happens."),Object(s.b)("p",null,"if-statements have the same structure as function definitions: a header followed by an indented body. Statements like this are called ",Object(s.b)("strong",{parentName:"p"},"compound statements"),"."),Object(s.b)("p",null,"There is no limit on the number of statements that can appear in the body, but there has to be at least one. Occasionally, it is useful to have a body with no statements (usually as a place keeper for code you haven\u2019t written yet). In that case, you can use the ",Object(s.b)("strong",{parentName:"p"},"pass")," statement, which does nothing."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if x < 0:\n    pass          # TODO: need to handle negative values!\n")),Object(s.b)("h3",{id:"alternative-execution"},"Alternative execution"),Object(s.b)("p",null,"A second form of the if statement is ",Object(s.b)("strong",{parentName:"p"},"alternative execution"),", in which there are two possibilities and the condition determines which one gets executed. The syntax looks like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if x%2 == 0:\n    print('x is even')\nelse:\n    print('x is odd')\n")),Object(s.b)("p",null,"If the remainder when x is divided by 2 is 0, then we know that x is even, and the program displays a message to that effect. If the condition is false, the second set of statements is executed. Since the condition must be true or false, exactly one of the alternatives will be executed. The alternatives are called branches, because they are branches in the flow of execution."),Object(s.b)("h3",{id:"chained-conditionals"},"Chained conditionals"),Object(s.b)("p",null,"Sometimes there are more than two possibilities and we need more than two branches. One way to express a computation like that is a chained conditional:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if x < y:\n    print('x is less than y')\nelif x > y:\n    print('x is greater than y')\nelse:\n    print('x and y are equal')\n")),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"elif")," is an abbreviation of \u201celse if.\u201d Again, exactly one branch will be executed. There is no limit on the number of elif statements. If there is an else clause, it has to be at the end, but there doesn\u2019t have to be one:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if choice == 'a':\n    draw_a()\nelif choice == 'b':\n    draw_b()\nelif choice == 'c':\n    draw_c()\n")),Object(s.b)("p",null,"Each condition is checked in order. If the first is false, the next is checked, and so on. If one of them is true, the corresponding branch executes, and the statement ends. ",Object(s.b)("strong",{parentName:"p"},"Even if more than one condition is true, only the first true branch executes.")),Object(s.b)("h3",{id:"nested-conditionals"},"Nested conditionals"),Object(s.b)("p",null,"One conditional can also be ",Object(s.b)("strong",{parentName:"p"},"nested")," within another. We could have written the trichotomy example like this:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if x == y:\n    print('x and y are equal')\nelse:\n    if x < y:\n        print('x is less than y')\n    else:\n        print('x is greater than y')\n")),Object(s.b)("p",null,"The outer conditional contains two branches. The first branch contains a simple statement. The second branch contains another if statement, which has two branches of its own. Those two branches are both simple statements, although they could have been conditional statements as well."),Object(s.b)("p",null,"Although the indentation of the statements makes the structure apparent, nested conditionals become difficult to read very quickly! In general, it is a good idea to avoid them when you can."),Object(s.b)("p",null,"Logical operators often provide a way to simplify nested conditional statements. For example, we can rewrite the following code using a single conditional:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if 0 < x:\n    if x < 10:\n        print('x is a positive single-digit number.')\n")),Object(s.b)("p",null,"The ",Object(s.b)("inlineCode",{parentName:"p"},"print")," statement is executed only if we make it past both conditionals, so we can get the same effect with the ",Object(s.b)("inlineCode",{parentName:"p"},"and")," operator:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"if 0 < x and x < 10:\n    print('x is a positive single-digit number.')\n")),Object(s.b)("h2",{id:"24"},"2.4"),Object(s.b)("h3",{id:"a-list-is-a-sequence"},"A list is a sequence"),Object(s.b)("p",null,"Like a string, a ",Object(s.b)("strong",{parentName:"p"},"list")," is a sequence of values. In a string, the values are characters; in a list, they can be any type. The values in a list are called ",Object(s.b)("strong",{parentName:"p"},"elements")," or sometimes items."),Object(s.b)("p",null,"There are several ways to create a new list; the simplest is to enclose the elements in square brackets, ",Object(s.b)("inlineCode",{parentName:"p"},"[ ]"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"[10, 20, 30, 40]\n['crunchy frog', 'ram bladder', 'lark vomit']\n")),Object(s.b)("p",null,"The first example is a list of four integers. The second is a list of three strings. The elements of a list don\u2019t have to be the same type. The following list contains a string, a float, an integer, and (lo!) another list:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"['spam', 2.0, 5, [10, 20]]\n")),Object(s.b)("p",null,"A list within another list is nested."),Object(s.b)("p",null,"A list that contains no elements is called an empty list; you can create one with empty brackets, ",Object(s.b)("inlineCode",{parentName:"p"},"[]"),"."),Object(s.b)("p",null,"As you might expect, you can assign list values to variables:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> numbers = [17, 123]\n>>> empty = []\n>>> print(cheeses, numbers, empty)\n['Cheddar', 'Edam', 'Gouda'] [17, 123] []\n")),Object(s.b)("h3",{id:"lists-are-mutable"},"Lists are mutable"),Object(s.b)("p",null,"The syntax for accessing the elements of a list is the same as for accessing the characters of a string\u2014the bracket operator. The expression inside the brackets specifies the index. ",Object(s.b)("strong",{parentName:"p"},"Remember that the indices start at 0"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> print(cheeses[0]) \nCheddar\n>>> print(cheeses[1])\nEdam\n")),Object(s.b)("p",null,"Unlike strings, lists are mutable. When the bracket operator appears on the left side of an assignment, it identifies the element of the list that will be assigned."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> numbers = [17, 123]\n>>> numbers[1] = 5\n>>> print(numbers)\n[17, 5]\n")),Object(s.b)("p",null,"The element at index 1, which used to be ",Object(s.b)("inlineCode",{parentName:"p"},"123"),", is now ",Object(s.b)("inlineCode",{parentName:"p"},"5"),"."),Object(s.b)(b,{mdxType:"CenteredDiv"},Object(s.b)("img",{alt:"Figure 10.1 - A depiction of how indices map to list elements",src:Object(o.a)("img/figure10-1.svg")}),Object(s.b)("p",null,"Figure 10.1")),Object(s.b)("p",null,"You can think of a list as a relationship between indices and elements. This relationship is called a ",Object(s.b)("strong",{parentName:"p"},"mapping"),"; each index \u201cmaps to\u201d one of the elements.  In figure 10.1, we can see a visual representation of mapping. Notice how each index of a list points to a corresponding element. We also see where, in our ",Object(s.b)("inlineCode",{parentName:"p"},"numbers")," list, the element at index 1 was changed.  The empty list has no elements at all, which also means no indices."),Object(s.b)("p",null,"Any integer expression can be used as an index. If you try to read or write an element that does not exist, you get an ",Object(s.b)("inlineCode",{parentName:"p"},"IndexError"),". If an index has a negative value, it counts backward from the end of the list:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> print(cheeses[-1]) \nGouda\n")),Object(s.b)("h2",{id:"25"},"2.5"),Object(s.b)("h3",{id:"list-operations"},"List operations"),Object(s.b)("p",null,"The + operator concatenates lists:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> a = [1, 2, 3]\n>>> b = [4, 5, 6]\n>>> c = a + b\n>>> print(c)\n[1, 2, 3, 4, 5, 6]\n")),Object(s.b)("p",null,"Similarly, the * operator repeats a list a given number of times:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> [0] * 4\n[0, 0, 0, 0]\n>>> [1, 2, 3] * 3\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\n")),Object(s.b)("p",null,"The first example repeats ",Object(s.b)("inlineCode",{parentName:"p"},"[0]")," four times. The second example repeats the list ",Object(s.b)("inlineCode",{parentName:"p"},"[1, 2, 3]")," three times."),Object(s.b)("h3",{id:"list-slices"},"List slices"),Object(s.b)("p",null,"The ",Object(s.b)("strong",{parentName:"p"},"slice")," operator works on lists:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> t[1:3]  # get a slice of the list starting at index 1 and ending right before index 3\n['b', 'c']\n>>> t[:4]  # get a slice of the list ending right before index 4\n['a', 'b', 'c', 'd']\n>>> t[3:]  # get a slice of the list starting at index 3\n['d', 'e', 'f']\n")),Object(s.b)("p",null,"If you omit the first index, the slice starts at the beginning. If you omit the second, the slice goes to the end. So if you omit both, the slice is a copy of the whole list."),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> t[:]\n['a', 'b', 'c', 'd', 'e', 'f']\n")),Object(s.b)("p",null,"Since lists are mutable, it is often useful to make a copy before performing operations that fold, spindle or mutilate lists."),Object(s.b)("p",null,"A slice operator on the left side of an assignment can update multiple elements:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> t = ['a', 'b', 'c', 'd', 'e', 'f']\n>>> t[1:3] = ['x', 'y']\n>>> print(t)\n['a', 'x', 'y', 'd', 'e', 'f']\n")),Object(s.b)("h3",{id:"list-methods"},"List methods"),Object(s.b)("p",null,"Python provides methods that operate on lists. For example, append adds a new element to the end of a list:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> t = ['a', 'b', 'c']\n>>> t.append('d')\n>>> print(t)\n['a', 'b', 'c', 'd']\n")),Object(s.b)("h3",{id:"deleting-elements"},"Deleting elements"),Object(s.b)("p",null,"There are several ways to delete elements from a list. If you know the index of the element you want, you can use ",Object(s.b)("inlineCode",{parentName:"p"},"pop"),":"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> t = ['a', 'b', 'c']\n>>> x = t.pop(1)\n>>> print(t)\n['a', 'c']\n>>> print(x)\nb\n")),Object(s.b)("p",null,Object(s.b)("inlineCode",{parentName:"p"},"pop")," modifies the list and returns the element that was removed. If you don\u2019t provide an index, it deletes and returns the last element."),Object(s.b)("p",null,"If you know the element you want to remove you can use remove:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> t = ['a', 'b', 'c']\n>>> t.remove('b')\n>>> print(t)\n['a', 'c']\n")),Object(s.b)("h3",{id:"the-in-operator"},"The in operator"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),">>> cheeses = ['Cheddar', 'Edam', 'Gouda']\n>>> 'Edam' in cheeses\nTrue\n>>> 'Brie' in cheeses\nFalse\n")),Object(s.b)("h2",{id:"26"},"2.6"),Object(s.b)("h3",{id:"the-while-statement"},"The while statement"),Object(s.b)("p",null,"Computers are often used to automate repetitive tasks. Repeating identical or similar tasks without making errors is something that computers do well and people do poorly."),Object(s.b)("p",null,"Here is an example countdown snippet that uses a while statement:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"while n > 0:\n    print(n)\n    n = n-1\nprint('Blastoff!')\n")),Object(s.b)("p",null,"You can almost read the ",Object(s.b)("inlineCode",{parentName:"p"},"while")," statement as if it were English. It means, \u201cWhile n is greater than 0, display the value of n and then reduce the value of n by 1. When you get to 0, display the word Blastoff!\u201d"),Object(s.b)("p",null,"More formally, here is the flow of execution for a while statement:"),Object(s.b)("p",null,"Evaluate the condition, yielding True or False.\nIf the condition is false, exit the while statement and continue execution at the next statement.\nIf the condition is true, execute the body and then go back to step 1.\nThis type of flow is called a loop because the third step loops back around to the top."),Object(s.b)("p",null,"The body of the loop should change the value of one or more variables so that eventually the condition becomes false and the loop terminates. Otherwise the loop will repeat forever, which is called an infinite loop. An endless source of amusement for computer scientists is the observation that the directions on shampoo, \u201cLather, rinse, repeat,\u201d are an infinite loop."),Object(s.b)("p",null,"In the case of countdown, we can prove that the loop terminates because we know that the value of n is finite, and we can see that the value of n gets smaller each time through the loop, so eventually we have to get to 0. In other cases, it is not so easy to tell:"),Object(s.b)("pre",null,Object(s.b)("code",Object(a.a)({parentName:"pre"},{className:"language-python"}),"while n != 1:\n    print (n)\n    if n%2 == 0:        # n is even\n        n = n//2\n    else:               # n is odd\n        n = n*3+1\n")),Object(s.b)("p",null,"The condition for this loop is ",Object(s.b)("inlineCode",{parentName:"p"},"n != 1"),", so the loop will continue until n is 1, which makes the condition false."),Object(s.b)("p",null,"Each time through the loop, the program outputs the value of ",Object(s.b)("inlineCode",{parentName:"p"},"n")," and then checks whether it is even or odd. If it is even, ",Object(s.b)("inlineCode",{parentName:"p"},"n")," is divided by 2. If it is odd, the value of ",Object(s.b)("inlineCode",{parentName:"p"},"n")," is replaced with ",Object(s.b)("inlineCode",{parentName:"p"},"n*3+1"),". For example, if the argument passed to sequence is 3, the resulting sequence is 3, 10, 5, 16, 8, 4, 2, 1."),Object(s.b)("p",null,"Since ",Object(s.b)("inlineCode",{parentName:"p"},"n")," sometimes increases and sometimes decreases, there is no obvious proof that n will ever reach 1, or that the program terminates. For some particular values of n, we can prove termination. For example, if the starting value is a power of two, then the value of n will be even each time through the loop until it reaches 1. The previous example ends with such a sequence, starting with 16."))}h.isMDXComponent=!0}}]);